/* 
 * Основные понятия и определения.
 * 
 *                                                Структура класса
 * Структура класса в Java может включать в себя блок инициализации полей, блок статической инициализации,
 * блок нестатической инициализации для объекта класса, методы и конструкторы класса (как частный случай методов).
 * 
 *                                                Сигнатура метода
 * Это имя метода и параметры. В сигнатуру метода не входит возвращаемое значение, бросаемые им исключения, а также модификаторы
 * (ключевые слова public, protected, private, abstract, static, final, synchronized, native, strictfp и разнообразные аннотации).
 * 
 *                                                Круглые скобки ()
 * В контексте конструктора или метода, являются частью конструкции конструктора или метода соответственно, т.е. скобки используются
 * в сочетании с именем конструктора или метода (устанавливаются после имени) как при их объявлении (конструкторов или методов),
 * так и при обращении к ним. Например, параметры метода инициализируются внутри круглых скобок:
 * 
 * public void method(int a) {}
 * 
 * где method – имя инициализируемого метода, public и void – модификаторы метода, {} – тело метода, (int a) – конструкция,
 * содержащая инициализацию переменной типа int в качестве аргумента (параметра) метода.
 * 
 *                                                Фигурные скобки {}
 * Синтаксисом языка принято, что область действия каждого оператора (начало и конец) должна быть обозначена фигурными скобками.
 * Верхний уровень, как правило, обозначается оператором class и его область действия может включать инициализацию полей,
 * блок статической и нестатической инициализации, конструкторы и методы. Границы (начало и конец) конструкторов, методов
 * и блоков инициализации так же обязаны быть обозначены фигурными скобками. Кроме того, фигурными скобками могут быть объединены
 * один или несколько операторов в отдельный исполняемый блок.
 * Исполняемый код в этой структуре может находится только в теле метода (конструктора, как частный случай метода)
 * или блоке статической (нестатической для объекта) инициализации и запущен на исполнение по имени этого метода
 * (в случае блока статической (нестатической) инициализации - в момент создания класса).
 * 
 *                                                   Точка/dot .
 * Разделитель, в математических расчетах используется для выделения элементов из ссылки на объект,
 * в контексте операторов import и package – для доступа к вложенному пакету/объекту/классу,
 * в контексте классов и методов – для доступа к переменным/методам и т.п.
 * 
 *                                                Точка с запятой ;
 * Синтаксис ; (точка с запятой) используется для обозначения конца оператора.
 * Компилятор воспринимает наличие точки с запятой в коде как конец инструкции/выражения. */




/* Оператор package сообщает транслятору, в каком пакете должны определяться содержащиеся в данном файле (CalcMain.java) классы.
 * Пакеты задают набор раздельных пространств имен, в которых хранятся имена классов.
 * Если оператор package не указан, классы попадают в безымянное пространство имен, используемое по умолчанию.
 * Если объявляется класс, принадлежащий определенному пакету, например – package pi.KR;, то и исходный код этого класса
 * должен храниться в каталоге /pi.KR */
package pi.KR;

/* Оператор import позволяет обращаться к классам, содержащемся в пакете, который указан между операторами import и ;
 * Он служит только для удобства программистов и не является обязательным с технической точки зрения для создания
 * завершенной Java-программы.
 * Т.е. все стандартные классы хранятся в каком-либо именованном пакете и, поскольку внутри пакетов классы должны быть полностью
 * определены именем или именами их пакетов, использование класса без обращения к пакету (без использования оператора import),
 * в котором находится класс, заранее, будет представлять собой длинную запись, в которой первым будет записано обращение к пакету,
 * а после – к классу, например:
 * 
 * javax.swing.JTextField firstTextField = new javax.swing.JTextField("Первое текстовое поле");
 * javax.swing.JTextField secondTextField = new javax.swing.JTextField("Второе текстовое поле");
 * javax.swing.JTextField thirdTextField = new javax.swing.JTextField("Третье текстовое поле");
 * 
 * В случае использования директивы импорта создание трех вышеперечисленных объектов класса JTextField будет иметь следующий вид:
 * 
 * import javax.swing.JTextField;
 * JTextField firstTextField = new JTextField("Первое текстовое поле");
 * JTextField secondTextField = new JTextField("Второе текстовое поле");
 * JTextField thirdTextField = new JTextField("Третье текстовое поле"). */
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.ImageIcon;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.net.URL;
import java.text.DecimalFormat;

/* Класс CalcMain является главным классом, определенным в данном файле (CalcMain.java).
 * Он наследуется от класса JFrame, поэтому для использования компонентов класса JFrame далее,
 * необходимость в объявлении объекта класса JFrame не возникнет. */
class CalcMain extends JFrame {
	
	/* private static final long serialVersionUID = 1L; – Конструкция используется для указания версии сериализованных данных.
	 * 
	 * Сериализация — процесс преобразования объекта в поток байтов для сохранения или передачи в память, базу данных или файл.
	 * Эта операция предназначена для того, чтобы сохранить состояния объекта для последующего воссоздания при необходимости.
	 * Обратный процесс называется десериализацией.
	 * 
	 * Среда выполнения сериализации связывает с каждым сериализуемым классом номер версии, называемый serialVersionUID,
	 * который используется во время десериализации для проверки того, что отправитель и получатель сериализованного объекта
	 * загрузили классы для этого объекта, которые совместимы в отношении сериализации.
	 * Если получатель загрузил класс для объекта, который имеет serialVersionUID отличный от класса соответствующего класса
	 * отправителя, то десериализация приведет к InvalidClassException.
	 * Сериализуемый класс может объявить свой собственный serialVersionUID явном виде, объявив поле с именем serialVersionUID
	 * которое должно быть статическим, конечным и типа long.
	 * Если сериализуемый класс явно не объявляет serialVersionUID, тогда среда выполнения сериализации вычислит значение
	 * serialVersionUID по умолчанию для этого класса на основе различных аспектов класса, как описано в
	 * Спецификации сериализации объектов Java (TM).
	 * Однако настоятельно рекомендуется, чтобы все сериализуемые классы явно объявляли значения serialVersionUID,
	 * так как вычисление serialVersionUID по умолчанию очень чувствительно к деталям класса, которые могут различаться
	 * в зависимости от реализаций компилятора, и, следовательно, могут привести к неожиданным InvalidClassExceptions
	 * во время десериализации.
	 * Поэтому, чтобы гарантировать согласованное значение serialVersionUID в различных реализациях Java-компилятора,
	 * сериализуемый класс должен объявить явное значение serialVersionUID.
	 * Также настоятельно рекомендуется, чтобы явные объявления serialVersionUID использовали модификатор private,
	 * где это возможно, поскольку такие объявления применяются только к немедленно объявленным полям класса.
	 * serialVersionUID не используются в качестве унаследованных членов. */
	private static final long serialVersionUID = 1L;
	
    /* Константы для расположения объектов:
     * x - отступ по ширине от левого края для области кнопок
     * y - отступ по высоте от верхнего края для области кнопок
     * xo - ширина объекта для области кнопок
     * xo - высота объекта для области кнопок
     * xI - отступ по ширине от левого края для области изображения
     * yI - отступ по высоте от верхнего края для области изображения
     * xoI - ширина объекта для области изображения
     * xoI - высота объекта для области изображения
     * Прочие переменные:
     * S1c - площадь одного стекла (применяется, если в остеклении используется больше 1 стекла) (Прямоугольная ОК)
     * S2c - площадь остекления типа double (Круглая ОК, Овальная ОК)
     * wfRectangle - площадь оконной рамы (Прямоугольная ОК)
     * wfRound - площадь оконной рамы (Круглая ОК)
     * wfOval - площадь оконной рамы (Овальная ОК)
     * selectedType - применяется для определения выбранного типа ОК в условии в слушателе кнопок actionPerformed()
     * (0 - Прямоугольная ОК, 1 - Круглая ОК, 2 - Овальная ОК) */
    final int x = 224; final int y = 10; final int xo = 99; final int yo = 29;
    final int xI = 82; final int yI = 200; final int xoI = 100; final int yoI = 29;
    int S1c; double S2c; int wfRectangle; double wfRound; double wfOval; byte selectedType = 0;
    
    /* Инициализация всех объектов.
     * 
     * Верхняя область окна содержит следующие объекты:
     * JLabel, принимающие в качестве параметра строки текста - labelType, labelHeight, labelWeight,
     * labelRadius, labelMaterial, labelSealing, labelAnswer1, labelAnswer2 labelAnswer3, labelAnswer4;
     * JTextField - fieldHeight, fieldWeight, fieldRadius;
     * JComboBox, принимающие в качестве параметра массивы строк - comboBox1, comboBox2, comboBox3;
     * JButton - buttonType, buttonCalculate.
     * 
     * Нижняя область окна содержит следующие объекты:
     * JLabel, принимающие в качестве параметра экземпляры ImageIcon - rectangleDefaultImageJLabel, rectangleImageJLabel,
     * roundDefaultImageJLabel, roundImageJLabel, ovalDefaultImageJLabel, ovalImageJLabel;
     * JLabel, принимающие в качестве параметра строки текста - imageLabelHeight, imageLabelHeightError, imageLabelWeight,
     * imageLabelWeightError, imageLabelRadius, imageLabelRadiusError, imageLabelGlass1, imageLabelGlassError1, imageLabelGlass2,
     * imageLabelGlassError2, imageLabelSealing, imageLabelSealingError, imageLabelWfRec, imageLabelWfErrorRec,
     * imageLabelWfRound, imageLabelWfErrorRound, imageLabelWfOval, imageLabelWfErrorOval.
     * 
     * Прочие параметры:
     * format - экземпляр класса DecimalFormat, в качестве параметра содержит форматирование;
     * error - строка со словом "Error", применяется для объектов со словом Error в конце их имени;
     * tooLongError - применяется для проверки на переполнение в условиях в методе calculation();
     * imageStringHeight - строка со значением высоты, полученным после проверки и вычисления;
     * imageStringWeight - строка со значением ширины, полученным после проверки и вычисления;
     * imageStringRadius - строка со значением радиуса, полученным после проверки и вычисления;
     * imageStringGlass1 - строка со значением площади первого стекла, полученным после проверки и вычисления;
     * imageStringGlass2 - строка со значением площади второго стекла, полученным после проверки и вычисления;
     * imageStringSealing - строка со значением площади уплотнения, полученным после проверки и вычисления;
     * imageStringWfRectangle - строка со значением площади оконной рамы, полученным после проверки и вычисления (Прямоугольная ОК);
     * imageStringWfRound - строка со значением площади оконной рамы, полученным после проверки и вычисления (Круглая ОК);
     * imageStringWfOval - строка со значением площади оконной рамы, полученным после проверки и вычисления (Овальная ОК). */
    JLabel labelType = new JLabel("Выберите оконную конструкцию");
    JLabel labelHeight = new JLabel("Высота (см)");
    JLabel labelWeight = new JLabel("Ширина (см)");
